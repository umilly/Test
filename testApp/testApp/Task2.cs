using System;
using System.Collections.Generic;
using System.Linq;

namespace testApp
{
    class Task2
    {

        int[] input =new int[10];
        public Task2()
        {
            var rnd = new Random();
            for (int i = 0; i < input.Length; i++)
                input[i] = rnd.Next(20)-10;
            //input = new int[4];
            //input[0] = -2;
            //input[1] = -2;
            //input[2] = 2;
            //input[3] = 2;
            process(0);
            //возможна разная трактовка данного задания
            //количество пар можно посчитать как количество перестановок либо количество сочетаний с учётом уникальности значения или без учёта.
            //Возьмём входное множество  x1=2,x2=2,x3=-2,x4=-2 и Х=0
            //1)тогда количество перестановок это (х1 х3) (х1 х4) (х2 х3) (х2 х4) (х3 х1) (х4 х1) (х3 х2) (х4 х2) 
            //итого 8 возможных вариантов пар удовлетворяющим условию по которому сумма равна Х
            //2)Если парой считать подмножество в котором порядок не важен пара(х1+х3)равна паре (х3+х1) то
            //то получим количество сочетаний соответсвенно (х1 х3) (х1 х4) (х2 х3) (х2 х4) сумма которых будет равна 4
            //3)если исключить возможность повтореного участия одного элемента исходного множества в нескольких парах
            //мы получим две пары хотя можем получить их двумя разными способами 1) (х1+х3)и(x2+x4)  2) (х1+х4)(х2+х3)
            //4)Вариант при котором пары с одинаковым набором слагаемых но собранных из разных элементов рассматриваются как одна пара мы исключаем 
            //так как явно не удовлетворяет условию "все".

            //Кроме того условие задачи впринципе поставленно некорректно, 1)не определён тип чисел 2)втором предложении отсутсвует ссылка на данные из первого.
            //и можно интерпретировать как поиск всех возможных пар слагаемых числа Х на множестве рациональных (или даже комплексных) чисел(не зависимо от входной коллекции).

            //Поэтому приступая к заданию мысленно довожу к наиболее веорятному и ввожу свои ограничения исключая неудобные варианты.
            //И закладываю возможность легко дополнить алгоритм при уточнении задания.

            //Есть коллекция "ЦЕЛЫХ" чисел и отдельное число Х. Надо вывести все сочетания из двух элементов заданной коллекции,
            //такие чтобы сумма элементов была равна заданному Х. При этом каждый элемент может быть участником только одного сочетания 
            //и не может использоваться повторно в другой паре.
            //Если существуют пары у которых значения элементов одинаково то уточнить количество таких пар.

            //В приведённом выше примере данный алгоритм с учётом корректировки условий приведёт к результату пара (-2,2) встречается 2 раза.
            //

        }
        public void process(int x)
        {
            //сложность алгоритма о(N)
            Dictionary<int, PairInfo> res = new Dictionary<int, PairInfo>();
            for (int i = 0; i < input.Length; i++)
            {
                var current = input[i];
                if (!res.ContainsKey(current))//o(1) ибо хештаблица
                {
                    var pi = new PairInfo(current,x);
                    res[current] = pi;
                    res[x - current] = pi;
                }
                res[current].AddSummand(current);
            }
          
            foreach(var pair in res.Values.Distinct())
            {                
                var count = Math.Min(pair.CountBig, pair.CountSmall);
                if (count > 0)
                {
                    Console.WriteLine($"pair '{pair.S1}' + '{pair.S2}' found {count} times");
                }
            }
        }
    }
}
